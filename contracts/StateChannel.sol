pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";
import "openzeppelin-solidity/contracts/cryptography/ECDSA.sol";
import "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol";


contract StateChannel {
    using SafeMath for uint256;
    using ECDSA for bytes32;

    /** Emitted when channel is opened.*/
    event ChannelOpened(
        address sender,
        address recipient,
        uint256 deposit,
        address token
    );

    /** Emitted when settlement is initiated. This event announces the opening of dispute period  */
    event SettlementInitiated(
        uint256 nonce,
        uint256 recipientBalance,
        address channel,
        uint256 finalizationBlock
    );

    /** Emitted when settlement is done */
    event Settled(
        uint256 recipientBalance,
        uint256 nonce,
        address sender,
        address recipient,
        bytes32 transactionHash
    );

    /** Struct representing a transaction */
    struct Transaction {
        uint256 nonce;
        uint256 recipientBalance;
        address stateChannel;
        uint256 finalizationBlock;
    }

    uint256 public constant DISPUTE_PERIOD = 1000;
    address payable public sender;
    address public recipient;
    uint256 public deposit;
    IERC20 public token;
    Transaction public settlementTransaction;

    constructor(
        address _recipient,
        IERC20 _token,
        uint256 _deposit
    ) public payable {

        sender = msg.sender;
        recipient = _recipient;
        token = _token;
        deposit = _deposit;

        require(
            token.transferFrom(sender, address(this), deposit),
            "Deposit amount is not approved"
        );

        emit ChannelOpened(sender, recipient, deposit, address(token));
    }

    /**
     * This function initiates the settlement.
     * _recipientBalance Total balance of recipient.
     * _nonce Number representing transaction count between parties.
     * _recipientSignedMessage Signature of recipient generated by signing transaction.
     * _senderSignedMessage Signature of sender generated by signing transaction.
     */
    function initiateSettlement(
        uint256 _recipientBalance,
        uint256 _nonce,
        bytes calldata _recipientSignedMessage,
        bytes calldata _senderSignedMessage
    )
        external
    {
        require(
            settlementTransaction.stateChannel == address(0),
            "State channel closing request exists."
        );
        require(
            _recipientBalance <= deposit,
            "Recipient balance should be less than deposit"
        );

        require(
            verifyTransaction(
                    _nonce,
                    _recipientBalance,
                    _recipientSignedMessage,
                    _senderSignedMessage
            ),
            "Transaction verification failed"
        );

        uint256 closingBlock = now + DISPUTE_PERIOD;
        settlementTransaction = Transaction(
            _nonce,
            _recipientBalance,
            address(this),
            closingBlock
        );

        emit SettlementInitiated(
            _nonce,
            _recipientBalance,
            address(this),
            closingBlock
        );
    }

    /**
     * This function finalizes the settlement.
     * _transactionHash Transaction hash.
     */
    function finalizeSettlement(
        bytes32 _transactionHash
    )
        external
    {
        require(
            settlementTransaction.stateChannel != address(0),
            "No state channel closing request exists."
        );

        bytes32 transactionHash = getTransactionHash(
            settlementTransaction.nonce,
            settlementTransaction.recipientBalance
        );

        require(
                _transactionHash == transactionHash,
                "Transaction Hash must match"
        );

        require(
            now >= settlementTransaction.finalizationBlock,
            "Channel cannot be closed in dispute period."
        );

        closeChannel(
            settlementTransaction.nonce,
            settlementTransaction.recipientBalance,
            transactionHash,
            sender
        );

    }

    /**
     * This function opens a dispute. Transaction with higher nonce must be submitted
     * to challenge the settlement.
     *
     * _recipientBalance Total balance of recipient.
     * _nonce Number representing transaction count between parties.
     * _recipientSignedMessage Signature of recipient generated by signing transaction.
     * _senderSignedMessage Signature of sender generated by signing transaction.
     *
     */
    function openDispute(
        uint256 _recipientBalance,
        uint256 _nonce,
        bytes calldata _recipientSignedMessage,
        bytes calldata _senderSignedMessage
    )
        external
    {
        require(
            settlementTransaction.stateChannel != address(0),
            "No state channel closing request exists."
        );

        require(
            now < settlementTransaction.finalizationBlock,
            "Dispute can't be opened after dispute duration is passed."
        );

        require(
            _nonce > settlementTransaction.nonce,
            "transaction for the dispute must have higher nonce than closing transaction"
        );

        require(
            verifyTransaction(
                _nonce,
                _recipientBalance,
                _recipientSignedMessage,
                _senderSignedMessage
            ),
            "Transaction verification failed"
        );

        // Sender is a bad actor.
        if (_recipientBalance > settlementTransaction.recipientBalance) {

            // Transfer amount to recipient and burn remaining amount
            closeChannel(
                _nonce,
                _recipientBalance,
                getTransactionHash(_nonce, _recipientBalance),
                address(0) // Burn remaining tokens
            );

            // Recipient is a bad actor.
        }else if (_recipientBalance < settlementTransaction.recipientBalance) {

            closeChannel(
                _nonce,
                0, // Donot pay to recipient and refund everything to sender.
                getTransactionHash(_nonce, _recipientBalance),
                sender
            );
        }

    }

    function getTransactionHash(
        uint256 _nonce,
        uint256 _balance
    )
        public
        view
        returns(bytes32)
    {
        return keccak256(
            abi.encodePacked(
                _nonce,
                _balance,
                address(this)
            )
        );
    }

    /**
     * This is a private function which closes channel.
     * This will send funds to recipient and return remaining balance to
     * beneficiary. 
     */
    function closeChannel(
        uint256 _nonce,
        uint256 _recipientBalance,
        bytes32 _transactionHash,
        address _remainingBalanceBeneficiary
    )
        private
    {

        require(
            token.transfer(recipient, _recipientBalance),
            "Recipient amount transfer failed"
        );

        require(
            token.transfer(_remainingBalanceBeneficiary, deposit.sub(_recipientBalance)),
            "Sender amount transfer failed"
        );

        emit Settled(
            _recipientBalance,
            _nonce,
            sender,
            recipient,
            _transactionHash
        );

        selfdestruct(sender);

    }

    function verifyTransaction(
        uint256 _nonce,
        uint256 _recipientBalance,
        bytes memory _recipientSignedMessage,
        bytes memory _senderSignedMessage
    )
        private
        view
        returns(bool)
    {
        bytes32 transactionHash = getTransactionHash(_nonce, _recipientBalance);

        require(
            isValidSignature(transactionHash, _recipientSignedMessage, recipient),
            "Invalid recipient signature"
        );
        require(
            isValidSignature(transactionHash, _senderSignedMessage, sender),
            "Invalid Sender signature"
        );
        return true;
    }

    function isValidSignature(
        bytes32 _transactionHash,
        bytes memory _signedMessage,
        address signer
    )
        private
        pure
        returns (bool)
    {
        bytes32 message = prefixed(_transactionHash);
        return message.recover(_signedMessage) == signer;
    }

    function prefixed(bytes32 _hash)
        private
        pure
        returns (bytes32)
    {
        return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", _hash));
    }
}